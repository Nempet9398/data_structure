# data_structure

# 추상자료형
---
복잡한 것을 가리고 필요한 것만 남겨놓는 것
SW = DATA + 명령코드
객체지향 SW = 객체의 집합



#시간 복잡
---
성능표기 -> BIG Oh 표기법
O(n) : 실행 시간 복잡도가 n에 비례

* log n
* n
* n log n
* n^2

## 빅오 표기법
---
example

* f(n) =5 -> O(1) , c= 10 이면 5< 10
* f(n) = 5 * 2^n -> O(2^n), c=10 일 때 5*2^n + 10 * n2 + 100 < 10 * 2^n 이기 때문에.

## 스택
---
탐색 -> 깊이 우선 탐색 (Depth - First Search(DFS))


## queue 원리
---
큐 -> FIFO 순서를 따름 : 들어가는 순서대로 나오는 것을 의미
뒤 (Rear)에서 들어와 앞 (Front)로 데이터가 나오게 됨

Front -> 삭제
Rear -> 삽입

선형 큐의 문제점 : 삭제를 하게 되면 모든 데이터를 이동해주어야한다. -> 원형 큐


큐 응용 : 대기열 시뮬레이션, 버퍼 , 너비 우선 탐색 (Breadth Fisrt Search / BFS)

## Deque (덱)
---
선입선출을 따르던 큐에서 양 옆으로 삽입, 삭제가
  get_num():
  return (rear - front + Size) % Size


## 연결리스트
---
노드 : 데이터와 링크로 구성
node1.data = data1
node1.link = node2 로 구성

노드 삽입 : 중간 연결리스트에 데이터 삽입
* 새 노드 생성 , 데이터 입력
* 새노드의 링크에 n+1 번째 노드 입력
* n-1 노드의  링크를 새 노드로 지정

노드 삭제 : 중간 데이터 삭제
* n-1 데이터 링크를 n+1 노드로 연결
* n번째 노드 삭제

코드 구현
* head : 첫번째 노드
* current : 현재 녿
* pre : 현재 처리중 바로 앞 노드

## 우선순위큐
---
우선순위를 가진 항목들을 저장하는 큐
우선순위가 높은 데이터가 먼저 나가게 됨

최대값 우선 큐 -> Max-heap
최소값 우선 큐 -> Min-heap

우선순위 큐 구현 비교


|표현 방법|삽입|삭제|
|:---:|:---:|:---:|
|순서 없는 배열|O(1)|O(n)|
|순서 없는 연결리스트|O(1)|O(1)|
|정렬된 배열|O(n)|O(1)|
|정렬된 연결 리스트|O(n)|O(1)|
|힙|O(log n)|O(log n)|

### heap (힙)
* 최대힙 - 부모 노드의 키값이 자식 노드키값보다 크거나 같은 완전 이진 트리
* 최소힙 - 부모 노드의 키값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

( 완전 트리 -> 위에서 아래로 갈 때 좌에서 우로 자식을 설정)

* 힙 각 노드에 번호를 붙임 ( 노드가 없어도 좌에서 우로 가상으로 있다고 생각 한 후 번호 설정) -> 배열의 인덱스로 설정

(시험문제 : 다운힙에서 디큐했을대 )



## 정렬(Sotring)
---
데이터를 순서대로 재배열 하는 것

* 단순하지만 비효율적 : 삽입, 선택, 버블정렬 -> O(n^2)
* 복잡하지만 효율적 : 퀵, 힙, 병합, 기수정렬, 팀 -> O(nlogn)

레코드 : 정렬시켜야 될 대상 - SQL의 인스턴스 같은 존재, 여러개의 필드(SQL의 속성) 으로 이루어짐

캐시메모리 :

* 내부 정렬 : 모든 데이터가 메인 메모리
* 외부 정렬 : 외부 기억장치에 대부분 레코드

-> 데이터를 메모리에 올려서 정렬

### 선택정렬(Selection Sort)
---
1. 전체리스트 스캔
2. 최소값을 찾음
3. 앞자리와 교환
4. 1-3을 반복

### 삽입정렬(Insertion Sort)
---
1. n과 n+1번째 카드 비교
2. 정렬된 리스트 사이에서 크기 비교
3. 사이에 넣기 위해 그 뒤에 데이터 이동
4. 1-3 반복

### 버블정렬(Bubble Sort)
---
인접한 2개 레코드 비교해 순서대로 교환
비교-교환 과정을 전체에 적용

### 쉘 정렬(Shell Sort)
---
-> 삽입 정렬은 어느정도 정렬된 리스트에서 대단히 빠른점을 이용
1. 리스트를 일정 간격(gap)의 부분 리스트로 나눔
2. 나뉘어진 리스트를 각각 삽입 정렬
3. 전체를 또 다시 삽입 정렬

gap -> 홀수 (실험적으로 좋음)

### 퀵 정렬(Quick Sort)
---
분할 정복법 : 리스트를 2개의 부분리스트로 분할

1. 첫번쨰를 피벗으로 설정
2. left , right를 설정해 low가 피벗보다 클때까지 이동, high를 피벗보다 작은항모까지 이동
3. low, high 항목 교체
4. 2-3 반복 진행
5. 재귀구조를 이용해 다시 처음에 선정했던 피벗을 기준으로 왼쪽 / 오른쪽을 나누어 진행

### 정렬 정리 (시간복잡도)
